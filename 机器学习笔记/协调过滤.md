### 协调过滤入门

协同过滤目前主要分为两种：

- UserCF（用户相似性）
- ItemCF（商品相似性）

**UserCF**

找到与与用户M相似的用户N
$$
用户相似度={{|{M}\bigcap{N}|}\over{|{M}\bigcup{N}|}} \\
或者\\
余弦相似度={|N(a)| \bigcap |N(b)|\over{\sqrt{|N(a)|*|N(b)|}}} \tag{1.1}
$$
然后 找到用户M

**ItemCF**

1、计算物品a与b之间的相似性度：
$$
W_{ij}={|N(i)| \bigcap |N(j)|\over{\sqrt{|N(i)|*|N(j)|}}} \tag{1.2}
$$
ItemCF与UserCF类似的基本思想都是同时喜欢物品ij的人数比上喜欢物品i与喜欢物品j总数有多少人，这个数值表示物品ij的相似程度  
当然可能有一些物品大部分人都喜欢所以可能对于头部物品每个物品跟他都会有点相似度，改进形式如下:  
**改进1**
$$

W_{ij}={{\sum_{u\in{N(i)\bigcap{N(j)}}}{1\over{log(1+|N(u)|)}}}\over{\sqrt{|N(i)| |Nj|}}}
$$
其实这两个公式的差别很简单：上一个的公式代表对于每个来说喜欢每个物品的每个用户的权重都是1不加区分的，但对于第二个公式来说每个物品的权重是喜欢每个物品的每个用户的权重与该用户喜欢物品总数的导数成反比，**这样过滤了一些爱好及其广泛的用户的干扰**

**改进2**
目前来说对于物品i跟物品j来说，j与i的相似度与j与i的相似度是相同的也就是说：
$$
W_{ij}=W_{ji}
$$
但是与物品i相似的其他物品，与物品j相似的其他物品是不同的，可能物品i只对A类物品相似性高，但是j对ABC类物品相似性都挺高。因此之前的公式并没有考虑到与物品i相似的物品有那些，因此**改进2**为：
$$
W‘_{ij}={{W_{ij}}\over{max_{j}w_{ij}}}
也就是在实践中我们会每一行都按照改行的最大值做归一化，这样W_{ij}与W_{ji}变得不相等了
$$

**改进3： 如何解决哈利波特问题**
哈利波特这本书很火，大部分的人都买过，因此，在计算相似图书的时候，基本每本书都会跟哈利波特这本书相似**公式1.2**中我们同时考虑了物品i与物品j的热度表现，但是如果j格外的火热的话那么分子$N(i)\bigcap{N(j)}$会无限接近于$N(i)$分子会很大，如果分母有不太大的时候，很可能每个物品都与头部物品有相关性，所以就产生了哈利波特问题。  
如何解决这样的问题呢，很简单就是要**惩罚那些热门物品**   
如果物品j很火热则公式变为：
$$
{|N(i)| \bigcap |N(j)|\over{{|N(i)|^(1-\alpha)*|N(j)|^\alpha}}}
$$
其中$a\in[0.5,1]$,当$\alpha$等于0.5那么他就是传统的ItemCF，$\alpha$越大则热门物品被惩罚越严重


### **ItemCF与UserCF的缺点**
任何的模型都有他使用的场景与不适用的场景，ItemCF与UserCF的场景比较明显就是两个热门分类的头部物品会很相似，比如大家都喜欢玩王者荣耀，大家都喜欢玩和平精英，那么ItemCF算出来的王者荣耀与和平精英的相似度一定会很高，CF算法不能够很好的将不同分类的物品区分开，这是他的缺点。